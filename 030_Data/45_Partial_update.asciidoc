[[partial-updates]]
=== document의 부분적인 업데이트

<<update-doc, 전체 Documents 업데이트>>에서, document를 업데이트하는 방식은((("updating documents", "partial updates")))((("documents", "partial updates"))) document를 검색해서 업데이트하고, 
전체 document를 다시 색인 한다고 언급했다. 이것은 사실이다. 그러나 `update` API를 사용하면, 단일 요청으로, counter를 증가시키는 것과 같은 부분적인 업데이트를 할 수 있다.

document는 불변(수정할 수 없고, 오직 대체해야 한다)이라고 언급했다. `update` API도 같은 원칙을 _가져야_ 한다. 
외부적으로는, document가 있던 곳에, 부분적으로 document를 업데이트하는 것처럼 나타난다. 그러나, 내부적으로, 
`update` API는 이미 언급한 것과 같이, 단순히 _검색해서-변경하고-재색인하는_ 프로세스를 따른다. 
차이점은 이 프로세스가 shard내에서 발생한다는 것이다. 이렇게 되면, 다중 요청에 의한 네트워크 부하를 피할 수 있다. 
_가져오고_, _재색인_하는 작업 사이의 시간을 절약하여, 다른 프로세스의 변경 사항과 충돌할 가능성도 줄어든다.

`업데이트` 요청의 가장 단순한 형태는, `doc` 매개변수로 document의 일부를 받아, 기존 document와 병합하는 것이다. 
오브젝트는 함께 병합되고, 기존의 숫자 field는 덮어 써지고, 새로운 field는 추가된다. 예를 들면, `tags` field와 `views` field를, 
블로그 포스트에 추가할 수 있다:

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

요청이 성공하면, `index` 요청과 유사한 응답을 볼 수 있다:

[source,js]
--------------------------------------------------
{
   "_index" :   "website",
   "_id" :      "1",
   "_type" :    "blog",
   "_version" : 3
}
--------------------------------------------------

document를 검색해 보면, 업데이트된 `_source` field를 볼 수 있다:

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  3,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags": [ "testing" ], <1>
      "views":  0 <1>
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

<1> 새로운 field가 `_source`에 추가되었다.

==== 부분 업데이트를 위한 script 사용

script는 `_source` field의 내용을 변경하기 위해, `update` API에서 사용될 수 있다. 
이것은((("_source field", sortas="source field"))) 업데이트 script내에서 `ctx._source`로 참조된다. 
예를 들면, 블로그 게시물이 가진, `views`의 수를 증가시키기 위해 script를 사용할 수 있다.

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "script" : "ctx._source.views+=1"
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

.Groovy scripting
****
API가 충분하지 않은 ((("documents", "partial updates", "using scripts")))((("updating documents", "partial updates", "using scripts")))경우에, 
Elasticsearch에서는 사용자 정의 로직을 script로 작성할 수 있다.((("scripts", "using to make partial updates"))) scripting은 검색, 정렬, 집계, 그리고 document 업데이트 같은, 많은 API를 지원한다. 
script는 요청의 일부로 전달될 수 있고, 특별한 index .scripts에서 가져오거나 디스크에서 로드 할 수 있다.
기본 script 언어는 javascript와 유사한 문법을 가지는, 빠른 표현 script 언어인 http://groovy.codehaus.org/[Groovy]((("Groovy"))) 이다. 
이것은 Elasticsearch 1.3버전에서 처음 소개되었으며, _샌드박스_에서 실행되지만, 공격자가 Groovy 스크립트를 구성해 샌드박스를 피해서 Elasticsearch Java VM을 구동중인
사용자로 쉘 명령어를 실행 시킬수 있는 Groovy 스크립팅 엔진의 취약 점이 있다.

그래서 v1.3.8, v1.4.3 과 v1.5.0 이상의 버전에서 기본적으로 비활성화 되어 있다.
또는 직접 클러스터의 모든 노드에 있는 `config/elasticsearch.yml` 파일에 설정을 추가하여 동적 Groovy 스크립트를 비횔성화 할 수 있다:
  
[source,yaml]
-----------------------------------
script.groovy.sandbox.enabled: false
-----------------------------------

이설정이 Groovy 샌드 박스는 종료 시키면, 동적 Groovy 스크립트가 특별한 `.scripts` 색인으로 부터의 요청이나 검색을 승인하는것을 방지한다.
여전히 모든 노드의 `config/scripts/` 디렉토리에 파일로 저장된 Groovy 스크립트는 사용 가능하다.

아키텍처와 보인상 취약점에 대한 우려가 필요하지 않은 경우, 예를 들자면 Elasticsearch 의 endpoints가 신뢰하는 응용프로그램들에게만 노출되고 사용가능하다면, 
응용프로그램의 필요에 따라 동적 스크립트을 다시 활성화 할 수 있다.

http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-scripting.html[스크립트 참조 문서].에서, script에 대해 더 많은 것을 읽을 수 있다.

****

`tags` 배열에 새로운 tag를 추가하기 위해서도 사용할 수 있다. 
이 예제에서 script 자체에 hard coding하지 않고, 새로운 tag를 매개변수로 지정했다. 
이것은 다른 tag를 추가할 때마다 새로운 script를 다시 compile하지 않고, 나중에 script를 재사용하기 위해서이다:

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "script" : "ctx._source.tags+=new_tag",
   "params" : {
      "new_tag" : "search"
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

document를 가져와 보면, 마지막 두 개의 요청의 효과를 볼 수 있다:

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  5,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags":  ["testing", "search"], <1>
      "views":  1 <2>
   }
}
--------------------------------------------------
<1> `search` tag가 `tags`에 추가되었다.
<2> `views` field가 증가하였다.

심지어, document의 내용을 기준으로, document를 삭제(`ctx.op`를 `delete`로 설정)할 수도 있다.

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "script" : "ctx.op = ctx._source.views == count ? 'delete' : 'none'",
    "params" : {
        "count": 1
    }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

==== 아직 존재하지 않는 document 업데이트

Elasticsearch에 ((("updating documents", "that don&#x27;t already exist")))pageview counter 저장한다고 가정해 보자. 
사용자가 page를 볼 때마다 page의 counter를 증가시켜야 한다. 그런데, 그 page가 새로운 page라면, counter가 이미 존재한다고 확신할 수 없다. 
아직 존재하지 않는 document를 업데이트하려 하면, 업데이트는 실패할 것이다.

이런 경우에, 존재하지 않을 경우에, 생성하도록 지정하는, `upsert` 매개변수를 지정할((("upsert parameter"))) 수 있다.

[source,js]
--------------------------------------------------
POST /website/pageviews/1/_update
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 1
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Upsert.json

이 요청을 처음 실행하면, `upsert` 값은 `views` field가 `1`로 초기화되어, 새로운 document로 색인 될 것이다. 
또 실행하면, document가 이미 존재하기 때문에, 증가시킨 `views` counter 가 `script`에 업데이트되어 적용 된다.

==== 업데이트와 충돌

이절을 소개하면서 _검색_ 과 _재색인_ 단계 사이는 더 작아, 변경 사항이 충돌할 기회가 더 작을 것이라고 이야기((("updating documents", "conflicts and")))((("conflicts", "updates and"))) 했다. 
그러나 가능성이 완전히 없을 수는 없다. 업데이트가 document를 재색인하기 전에, 다른 프로세스가 document `업데이트` 요청을 보낼 가능성은 여전하다.

데이터 손실을 방지하기 위해, `update` API는 _검색_ 단계에서 document의 현재 `_version`을 가져오고, _재색인_ 단계에서 `색인` 요청에 그것을 넘긴다. 
검색와 재색인 사이에서 다른 프로세스가 document를 업데이트하면, `_version` 넘버가 일치하지 않아, 업데이트 요청은 실패한다.

부분 업데이트 중 많은 경우에 있어, document가 업데이트되었다는 것은 문제가 아니다. 예를 들자면, 
두 개의 프로세스가 모두 page view counter를 증가시키려고 하면, 발생한 순서는 관계없다. 만약 충돌이 일어나면, 업데이트을 다시 시도하면 된다.

실패하기 전에, `업데이트`를 재시도 할 횟수를 `retry_on_conflict`에 설정하여, 자동으로(("query strings", "retry_on_conflict parameter")))((("retry_on_conflict parameter"))) 이를 수행할 수 있다. 
기본값은 `0`이다.

[source,js]
--------------------------------------------------
POST /website/pageviews/1/_update?retry_on_conflict=5 <1>
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 0
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Upsert.json
<1> 실패하면 5번을 재시도한다.

이 동작은 증가의 순서가 중요하지 않은 경우에는 잘 된다. 그러나, 변경의 순서가 중요한 다른 상황도 _있다_. <<index-doc, `index` API>>처럼, 
`update` API는 기본적으로 _last-write-wins_ 라는 방식을 채택하지만, <<optimistic-concurrency-control, 낙관적 동시성 제어>> 를 사용할 수 있도록, 
업데이트하려는 document의 버전을 지정 할 수도 있다.