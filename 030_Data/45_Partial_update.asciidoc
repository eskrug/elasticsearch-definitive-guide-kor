[[partial-updates]]
=== Partial Updates to Documents

=== document의 부분적인 업데이트

In <<update-doc>>, we said that ((("updating documents", "partial updates")))((("documents", "partial updates")))the way to update a document is to retrieve
it, change it, and then reindex the whole document. This is true. However, using
the `update` API, we can make partial updates like incrementing a counter in a
single request.

<<update-doc, 전체 Documents 업데이트>>에서, document를 업데이트하는 방식은((("updating documents", "partial updates")))((("documents", "partial updates"))) document를 검색해서 업데이트하고, 
전체 document를 다시 색인 한다고 언급했다. 이것은 사실이다. 그러나 `update` API를 사용하면, 단일 요청으로, counter를 증가시키는 것과 같은 부분적인 업데이트를 할 수 있다.

We also said that documents are immutable: they cannot be changed, only
replaced.  The `update` API _must_ obey the same rules.  Externally, it
appears as though we are partially updating a document in place. Internally,
however, the `update` API simply manages the same _retrieve-change-reindex_
process that we have already described. The difference is that this process
happens within a shard, thus avoiding the network overhead of multiple
requests. By reducing the time between the _retrieve_ and _reindex_ steps, we
also reduce the likelihood of there being conflicting changes from other
processes.

document는 불변(수정할 수 없고, 오직 대체해야 한다)이라고 언급했다. `update` API도 같은 원칙을 _가져야_ 한다. 
외부적으로는, document가 있던 곳에, 부분적으로 document를 업데이트하는 것처럼 나타난다. 그러나, 내부적으로, 
`update` API는 이미 언급한 것과 같이, 단순히 _검색해서-변경하고-재색인하는_ 프로세스를 따른다. 
차이점은 이 프로세스가 shard내에서 발생한다는 것이다. 이렇게 되면, 다중 요청에 의한 네트워크 부하를 피할 수 있다. 
_가져오고_, _재색인_하는 작업 사이의 시간을 절약하여, 다른 프로세스의 변경 사항과 충돌할 가능성도 줄어든다.

The simplest form of the `update` request accepts a partial document as the
`doc` parameter, which just gets merged with the existing document. Objects
are merged together, existing scalar fields are overwritten, and new fields are
added. For instance, we could add a `tags` field and a `views` field to our
blog post as follows:

`업데이트` 요청의 가장 단순한 형태는, `doc` 매개변수로 document의 일부를 받아, 기존 document와 병합하는 것이다. 
오브젝트는 함께 병합되고, 기존의 숫자 field는 덮어 써지고, 새로운 field는 추가된다. 예를 들면, `tags` field와 `views` field를, 
블로그 포스트에 추가할 수 있다:

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

If the request succeeds, we see a response similar to that
of the `index` request:

요청이 성공하면, `index` 요청과 유사한 응답을 볼 수 있다:

[source,js]
--------------------------------------------------
{
   "_index" :   "website",
   "_id" :      "1",
   "_type" :    "blog",
   "_version" : 3
}
--------------------------------------------------

Retrieving the document shows the updated `_source` field:

document를 검색해 보면, 업데이트된 `_source` field를 볼 수 있다:

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  3,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags": [ "testing" ], <1>
      "views":  0 <1>
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

<1> Our new fields have been added to the `_source`.

<1> 새로운 field가 `_source`에 추가되었다.

==== Using Scripts to Make Partial Updates

==== 부분 업데이트를 위한 script 사용


Scripts can be used in the `update` API to change the contents of the `_source`
field, which ((("_source field", sortas="source field")))is referred to inside an update script as `ctx._source`. For
instance, we could use a script to increment the number of `views` that our
blog post has had:

script는 `_source` field의 내용을 변경하기 위해, `update` API에서 사용될 수 있다. 
이것은((("_source field", sortas="source field"))) 업데이트 script내에서 `ctx._source`로 참조된다. 
예를 들면, 블로그 게시물이 가진, `views`의 수를 증가시키기 위해 script를 사용할 수 있다.

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "script" : "ctx._source.views+=1"
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

.Scripting with Groovy
****

For those ((("documents", "partial updates", "using scripts")))((("updating documents", "partial updates", "using scripts")))moments when the API just isn't enough, Elasticsearch allows you to
write your own custom logic in a script.((("scripts", "using to make partial updates"))) Scripting is supported in many APIs
including search, sorting, aggregations, and document updates. Scripts can be passed in as part of the request,
retrieved from the special .scripts index, or loaded from disk.

The default scripting language ((("Groovy")))is http://groovy.codehaus.org/[Groovy], a
fast and expressive scripting language, similar in syntax to JavaScript. It was first introduced
in Elasticsearch version v1.3.0 and it runs in a _sandbox_, however there is vulnerability
in the Groovy scripting engine that allows an attacker to construct
Groovy scripts that escape the sandbox and execute shell commands as the user
running the Elasticsearch Java VM.

Therefore in versions v1.3.8, v1.4.3, and version v1.5.0 and newer it has been disabled by default.
Alternatively you can disable dynamic Groovy scripts by
adding this setting to the `config/elasticsearch.yml` file in all nodes in the
cluster:

[source,yaml]
-----------------------------------
script.groovy.sandbox.enabled: false
-----------------------------------

This will turn off the Groovy sandbox, thus preventing dynamic Groovy scripts
from being accepted as part of a request or retrieved from the special
`.scripts` index. You will still be able to use Groovy scripts stored in files
in the `config/scripts/` directory on every node.

If your architecture and security is one that does not need worry about the vulnerability,
for example your Elasticsearch endpoints are only exposed and available to trusted applications,
then you can choose to re-enable the dynamic scripting if it is a feature your application needs.

You can read more about scripting in the
http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-scripting.html[scripting reference documentation].

****

.Groovy scripting
****
API가 충분하지 않은 ((("documents", "partial updates", "using scripts")))((("updating documents", "partial updates", "using scripts")))경우에, 
Elasticsearch에서는 사용자 정의 로직을 script로 작성할 수 있다.((("scripts", "using to make partial updates"))) scripting은 검색, 정렬, 집계, 그리고 document 업데이트 같은, 많은 API를 지원한다. 
script는 요청의 일부로 전달될 수 있고, 특별한 index .scripts에서 가져오거나 디스크에서 로드 할 수 있다.
기본 script 언어는 javascript와 유사한 문법을 가지는, 빠른 표현 script 언어인 http://groovy.codehaus.org/[Groovy]((("Groovy"))) 이다. 
이것은 Elasticsearch 1.3버전에서 처음 소개되었으며, _샌드박스_에서 실행되지만, 공격자가 Groovy 스크립트를 구성해 샌드박스를 피해서 Elasticsearch Java VM을 구동중인
사용자로 쉘 명령어를 실행 시킬수 있는 Groovy 스크립팅 엔진의 취약 점이 있다.

그래서 v1.3.8, v1.4.3 과 v1.5.0 이상의 버전에서 기본적으로 비활성화 되어 있다.
또는 직접 클러스터의 모든 노드에 있는 `config/elasticsearch.yml` 파일에 설정을 추가하여 동적 Groovy 스크립트를 비횔성화 할 수 있다:
  
[source,yaml]
-----------------------------------
script.groovy.sandbox.enabled: false
-----------------------------------

이설정이 Groovy 샌드 박스는 종료 시키면, 동적 Groovy 스크립트가 특별한 `.scripts` 색인으로 부터의 요청이나 검색을 승인하는것을 방지한다.
여전히 모든 노드의 `config/scripts/` 디렉토리에 파일로 저장된 Groovy 스크립트는 사용 가능하다.

아키텍처와 보인상 취약점에 대한 우려가 필요하지 않은 경우, 예를 들자면 Elasticsearch 의 endpoints가 신뢰하는 응용프로그램들에게만 노출되고 사용가능하다면, 
응용프로그램의 필요에 따라 동적 스크립트을 다시 활성화 할 수 있다.

http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-scripting.html[스크립트 참조 문서].에서, script에 대해 더 많은 것을 읽을 수 있다.

****

We can also use a script to add a new tag to the `tags` array.  In this
example we specify the new tag as a parameter rather than hardcoding it in
the script itself. This allows Elasticsearch to reuse the script in the
future, without having to compile a new script every time we want to add
another tag:

`tags` 배열에 새로운 tag를 추가하기 위해서도 사용할 수 있다. 
이 예제에서 script 자체에 hard coding하지 않고, 새로운 tag를 매개변수로 지정했다. 
이것은 다른 tag를 추가할 때마다 새로운 script를 다시 compile하지 않고, 나중에 script를 재사용하기 위해서이다:

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "script" : "ctx._source.tags+=new_tag",
   "params" : {
      "new_tag" : "search"
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json


Fetching the document shows the effect of the last two requests:

document를 가져와 보면, 마지막 두 개의 요청의 효과를 볼 수 있다:

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  5,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags":  ["testing", "search"], <1>
      "views":  1 <2>
   }
}
--------------------------------------------------
<1> The `search` tag has been appended to the `tags` array.
<2> The `views` field has been incremented.

<1> `search` tag가 `tags`에 추가되었다.
<2> `views` field가 증가하였다.


We can even choose to delete a document based on its contents,
by setting `ctx.op` to `delete`:

심지어, document의 내용을 기준으로, document를 삭제(`ctx.op`를 `delete`로 설정)할 수도 있다.

[source,js]
--------------------------------------------------
POST /website/blog/1/_update
{
   "script" : "ctx.op = ctx._source.views == count ? 'delete' : 'none'",
    "params" : {
        "count": 1
    }
}
--------------------------------------------------
// SENSE: 030_Data/45_Partial_update.json

==== Updating a Document That May Not Yet Exist

==== 아직 존재하지 않는 document 업데이트

Imagine that we need to store a((("updating documents", "that don&#x27;t already exist"))) page view counter in Elasticsearch. Every time
that a user views a page, we increment the counter for that page.  But if it
is a new page, we can't be sure that the counter already exists. If we try to
update a nonexistent document, the update will fail.

Elasticsearch에 ((("updating documents", "that don&#x27;t already exist")))pageview counter 저장한다고 가정해 보자. 
사용자가 page를 볼 때마다 page의 counter를 증가시켜야 한다. 그런데, 그 page가 새로운 page라면, counter가 이미 존재한다고 확신할 수 없다. 
아직 존재하지 않는 document를 업데이트하려 하면, 업데이트는 실패할 것이다.

In cases like these, we can use((("upsert parameter"))) the `upsert` parameter to specify the
document that should be created if it doesn't already exist:

이런 경우에, 존재하지 않을 경우에, 생성하도록 지정하는, `upsert` 매개변수를 지정할((("upsert parameter"))) 수 있다.

[source,js]
--------------------------------------------------
POST /website/pageviews/1/_update
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 1
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Upsert.json

The first time we run this request, the `upsert` value is indexed as a new
document, which  initializes the `views` field to `1`. On subsequent runs, the
document already exists, so the `script` update is applied instead,
incrementing the `views` counter.

이 요청을 처음 실행하면, `upsert` 값은 `views` field가 `1`로 초기화되어, 새로운 document로 색인 될 것이다. 
또 실행하면, document가 이미 존재하기 때문에, 증가시킨 `views` counter 가 `script`에 업데이트되어 적용 된다.

==== Updates and Conflicts

==== 업데이트와 충돌

In the introduction to this section, we said((("updating documents", "conflicts and")))((("conflicts", "updates and"))) that the smaller the window between
the _retrieve_ and _reindex_ steps, the smaller the opportunity for
conflicting changes. But it doesn't eliminate the possibility completely. It
is still possible that a request from another process could change the
document before `update` has managed to reindex it.

이절을 소개하면서 _검색_ 과 _재색인_ 단계 사이는 더 작아, 변경 사항이 충돌할 기회가 더 작을 것이라고 이야기((("updating documents", "conflicts and")))((("conflicts", "updates and"))) 했다. 
그러나 가능성이 완전히 없을 수는 없다. 업데이트가 document를 재색인하기 전에, 다른 프로세스가 document `업데이트` 요청을 보낼 가능성은 여전하다.

To avoid losing data, the `update` API retrieves the current `_version`
of the document in the _retrieve_ step, and passes that to the `index` request
during the _reindex_ step.
If another process has changed the document between retrieve and reindex,
then the `_version` number won't match and the update request will fail.

데이터 손실을 방지하기 위해, `update` API는 _검색_ 단계에서 document의 현재 `_version`을 가져오고, _재색인_ 단계에서 `색인` 요청에 그것을 넘긴다. 
검색와 재색인 사이에서 다른 프로세스가 document를 업데이트하면, `_version` 넘버가 일치하지 않아, 업데이트 요청은 실패한다.

For many uses of partial update, it doesn't matter that a document has been
changed.  For instance, if two processes are both incrementing the page-view counter, it doesn't matter in which order it happens; if a conflict
occurs, the only thing we need to do is reattempt the update.

부분 업데이트 중 많은 경우에 있어, document가 업데이트되었다는 것은 문제가 아니다. 예를 들자면, 
두 개의 프로세스가 모두 page view counter를 증가시키려고 하면, 발생한 순서는 관계없다. 만약 충돌이 일어나면, 업데이트을 다시 시도하면 된다.

This can be done automatically by((("query strings", "retry_on_conflict parameter")))((("retry_on_conflict parameter"))) setting the `retry_on_conflict` parameter to
the number of times that `update` should retry before failing; it defaults
to `0`.

실패하기 전에, `업데이트`를 재시도 할 횟수를 `retry_on_conflict`에 설정하여, 자동으로(("query strings", "retry_on_conflict parameter")))((("retry_on_conflict parameter"))) 이를 수행할 수 있다. 
기본값은 `0`이다.

[source,js]
--------------------------------------------------
POST /website/pageviews/1/_update?retry_on_conflict=5 <1>
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 0
   }
}
--------------------------------------------------
// SENSE: 030_Data/45_Upsert.json
<1> Retry this update five times before failing.

<1> 실패하면 5번을 재시도한다.

This works well for operations such as incrementing a counter, where the order of
increments does not matter, but in other situations the order of
changes _is_ important. Like the <<index-doc,`index` API>>, the `update` API
adopts a _last-write-wins_ approach by default, but it also accepts a
`version` parameter that allows you to use
<<optimistic-concurrency-control,optimistic concurrency control>> to specify
which version of the document you intend to update.

이 동작은 증가의 순서가 중요하지 않은 경우에는 잘 된다. 그러나, 변경의 순서가 중요한 다른 상황도 _있다_. <<index-doc, `index` API>>처럼, 
`update` API는 기본적으로 _last-write-wins_ 라는 방식을 채택하지만, <<optimistic-concurrency-control, 낙관적 동시성 제어>> 를 사용할 수 있도록, 
업데이트하려는 document의 버전을 지정 할 수도 있다.

