=== Retrieving Multiple Documents

=== 다수의 document 검색

As fast as Elasticsearch is, it can be faster still.((("documents", "retrieving multiple"))) Combining multiple
requests into one avoids the network overhead of processing each request
individually. If you know that you need to retrieve multiple documents from
Elasticsearch, it is faster to retrieve them all in a single request by using the
_multi-get_, or `mget`, API, ((("mget (multi-get) API")))instead of document by document.

Elasticsearch가 빠른 만큼, 여전히 더 빨라질 수 있다.((("documents", "retrieving multiple"))) 다수의 요청을 하나로 조합하는 것은, 
각 요청을 개별적으로 처리하는 경우에 발생하는 네트워크 부하를 피할 수 있다. 만약 Elasticsearch에서 다수의 document를 검색할 필요가 있다면, 
document 별로 검색하는 대신, _multi-get_이나 `mget` API((("mget (multi-get) API")))를 사용하여, 한번의 요청으로 모두 가져오는 것이 더 빠르다.

The `mget` API expects a `docs` array, each ((("docs array", "in request")))element of which specifies the
`_index`, `_type`, and `_id` metadata of the document you wish to retrieve. You
can also specify a `_source` parameter if you just want to retrieve one or
more specific fields:

`mget` API는 각 ((("docs array", "in request")))요소가 가져오려는 document의 `_index`, `_type`, `_id`의
 metadata를 가진 docs 배열을 지정해야 한다. 하나 이상의 특정 field만 가져오려면, `_source` field를 지정할 수도 있다:

[source,js]
--------------------------------------------------
GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

The response body also contains a `docs` array((("docs array", "in response body"))) that contains a response
per document, in the same order as specified in the request. Each of these
responses is the same response body that we would expect from an individual
<<get-doc,`get` request>>:

응답 body도 요청에서 지정한 것과 동일한 순서로, document별로 응답을 포함하는 `docs` 배열을((("docs array", "in response body"))) 포함한다. 
이들 응답 각각은 개별 <<get-doc, `get` 요청>>에서 얻은 응답 body와 같다.

[source,js]
--------------------------------------------------
{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

If the documents you wish to retrieve are all in the same `_index` (and maybe
even of the same `_type`), you can specify a default `/_index` or a
default `/_index/_type` in the URL.

동일한 `_index`에 있는(심지어 동일한 `_type`의) 모든 document를 검색하려 한다면, URL에 기본 `/_index`나 기본 `/_index/_type`을 지정하면 된다.

You can still override these values in the individual requests:

개별 요청에 이런 값들을 재정의하면 된다:

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

In fact, if all the documents have the same `_index` and `_type`, you
can just pass an array of `ids` instead of the full `docs` array:

사실, 모든 document가 동일한 `_index`와 `_type`을 가진다면, 모든 `docs` 배열 대신에, `ids`의 배열을 넘겨도 된다:

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}
--------------------------------------------------

Note that the second document that we requested doesn't exist. We specified
type `blog`, but the document with ID `1` is of type `pageviews`. This
nonexistence is reported in the response body:

요청한 것 중 두 번째 document가 존재하지 않는다는 것을 눈 여겨 보자. type을 `blog`로 지정했으나, 
`pageviews` type의 document ID를 `1`로 지정했다. 응답 body에 document가 존재하지 않는다고 나타난다:

[source,js]
--------------------------------------------------
{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  <1>
    }
  ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json
<1> This document was not found.

<1> 이 document는 존재하지 않는다.

The fact that the second document wasn't found didn't affect the retrieval of
the first document. Each doc is retrieved and reported on individually.

두 번째 document가 발견되지 않는다는 사실은, 첫 번째 document를 검색하는데 아무런 영향을 
미치지 못한다. 각 document는 개별적으로 검색되고 보고된다.

[NOTE]
====
The HTTP status code for the preceding request is `200`, even though one
document wasn't found. In fact, it would still be `200` if _none_ of the
requested documents were found--because the `mget`
request itself completed successfully. To determine the success or failure of
the individual documents, you need to check ((("found flag")))the `found` flag.
====

[NOTE]
====
비록 document가 하나도 발견되지 않았지만, 위의 요청에 대한 HTTP 상태 code는 `200`이다. 
사실, document가 _전혀_  발견되지 않아도 여전히 `200`이다. 그 이유는 `mget` 요청 자체가 성공적으로 완료되었기 때문이다. 
개별 document의 성공 여부를 결정하려면 ((("found flag")))`found` flag를 확인해야 한다.
====
