=== Retrieving Multiple Documents

=== 여러 document를 가져오자

As fast as Elasticsearch is, it can be faster still.((("documents", "retrieving multiple"))) Combining multiple
requests into one avoids the network overhead of processing each request
individually. If you know that you need to retrieve multiple documents from
Elasticsearch, it is faster to retrieve them all in a single request by using the
_multi-get_, or `mget`, API, ((("mget (multi-get) API")))instead of document by document.

Elasticsearch가 빠른 만큼, 여전히 더 빨라질 수 있다. 다수의 요청을 하나로 조합하는 것은, 각 요청을 개별적으로 처리하는 경우에 발생하는 네트워크 부하를 피할 수 있다. 만약 Elasticsearch에서 다수의 document를 가져올 필요가 있다면, document 별로 가져오는 대신, multi-get이나 mget API를 사용하여, 한번의 요청으로 그들 모두를 가져오는 것이 더 빠르다.

The `mget` API expects a `docs` array, each ((("docs array", "in request")))element of which specifies the
`_index`, `_type`, and `_id` metadata of the document you wish to retrieve. You
can also specify a `_source` parameter if you just want to retrieve one or
more specific fields:

mget API는 각 요소가 가져오려는 document의 _index, _type, _id의 metadata를 가진 docs 배열을 지정해야 한다. 하나 이상의 특정 field만 가져오려면, _source field를 지정할 수도 있다.

[source,js]
--------------------------------------------------
GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

The response body also contains a `docs` array((("docs array", "in response body"))) that contains a response
per document, in the same order as specified in the request. Each of these
responses is the same response body that we would expect from an individual
<<get-doc,`get` request>>:

응답 body도 요청에서 지정한 것과 동일한 순서로, document별로 응답을 포함하는 docs 배열을 포함한다. 이들 응답 각각은 개별 GET 요청(p.38)에서 얻은 응답 body와 같다.

[source,js]
--------------------------------------------------
{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

If the documents you wish to retrieve are all in the same `_index` (and maybe
even of the same `_type`), you can specify a default `/_index` or a
default `/_index/_type` in the URL.

동일한 index에 있는(심지어 동일한 _type의) 모든 document를 가져오려 한다면, URL에 기본 /_index나 기본 /_index/_type을 지정하면 된다.

You can still override these values in the individual requests:

개별 요청에 이런 값들을 재정의하면 된다.

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

In fact, if all the documents have the same `_index` and `_type`, you
can just pass an array of `ids` instead of the full `docs` array:

사실, 모든 document가 동일한 _index와 _type을 가진다면, 모든 docs 배열 대신에, id의 배열을 넘겨도 된다.

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}
--------------------------------------------------

Note that the second document that we requested doesn't exist. We specified
type `blog`, but the document with ID `1` is of type `pageviews`. This
nonexistence is reported in the response body:

요청한 것 중 두 번째 document가 존재하지 않는다는 것을 눈 여겨 보자. type을 blog로 지정했으나, pageview type의 document ID를 1로 지정했다. 응답 body에 document가 존재하지 않는다고 나타난다.

[source,js]
--------------------------------------------------
{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  <1>
    }
  ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json
<1> This document was not found.

<1> 이 document는 존재하지 않는다.

The fact that the second document wasn't found didn't affect the retrieval of
the first document. Each doc is retrieved and reported on individually.

두 번째 document가 발견되지 않는다는 사실은, 첫 번째 document를 가져오는데 아무런 영향을 미치지 못한다. 각 document는 개별적으로 가져오고 보고된다.

[NOTE]
====
The HTTP status code for the preceding request is `200`, even though one
document wasn't found. In fact, it would still be `200` if _none_ of the
requested documents were found--because the `mget`
request itself completed successfully. To determine the success or failure of
the individual documents, you need to check ((("found flag")))the `found` flag.
====

[NOTE]
====
비록 document가 하나 발견되지 않았지만, 위의 요청에 대한 HTTP status code는 200이다. 사실, document가 모두 다 발견되지 않아도 여전히 200이다. 그 이유는 mget 요청 자체가 성공적으로 완료되었기 때문이다. 개별 document의 성공 여부를 결정하려면 found flag를 확인해야 한다.
====
