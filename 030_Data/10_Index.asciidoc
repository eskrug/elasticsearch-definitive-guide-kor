[[index-doc]]
=== Indexing a Document

=== document 색인

Documents are _indexed_&#x2014;stored and made ((("documents", "indexing")))((("indexing", "a document")))searchable--by using the `index`
API. But first, we need to decide where the document  lives.  As we just
discussed, a document's `_index`, `_type`, and `_id` uniquely identify the
document.  We can either provide our own `_id` value or let the `index` API
generate one for us.

document는 ((("documents", "indexing")))((("indexing", "a document")))index API에 의해 _색인&#x2014;저장되고 검색 가능하도록 만들어진&#x2014;된다_. 
그러나 먼저, document를 어디에 저장할지를 결정해야 한다. 
방금 이야기했듯이 document의 `_index`, `_type`, `_id`는 document를 유일하게 식별할 수 있다. 
우리가 우리 고유의 `_id` 값을 지정하거나, 아니면 `index`API에서 자동으로 생성해 준다.

==== Using Our Own ID

==== 고유한 ID 사용

If your document has a natural ((("id", "providing for a document")))identifier (for example, a `user_account` field
or some other value that identifies the document), you should provide
your own `_id`, using this form of the `index` API:

만약 당신의 document가 고유의 ((("id", "providing for a document")))식별자(예: `user_account field`나 document를 식별할 수 있는 어떤 다른 값)를 가지고 있다면, 
아래 형태의 `index` API로, 자기 자신만의 `_id`를 제공할 수 있다:

[role="pagebreak-before"]
[source,js]
--------------------------------------------------
PUT /{index}/{type}/{id}
{
  "field": "value",
  ...
}
--------------------------------------------------

For example, if our index is called `website`, our type is called `blog`,
and we choose the ID `123`, then the index request looks like this:

예를 들자면, `website`라는 index에 `blog`라는 type에 `123`이라는 ID라면, index 요청은 아래와 같다:

[source,js]
--------------------------------------------------
PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "Just trying this out...",
  "date":  "2014/01/01"
}
--------------------------------------------------
// SENSE: 030_Data/10_Create_doc_123.json

Elasticsearch responds as follows:

Elasticsearch의 응답은 아래와 같다:

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "123",
   "_version":  1,
   "created":   true
}
--------------------------------------------------


The response indicates that the indexing request has been successfully created
and includes the `_index`, `_type`, and `_id` metadata, and a new element:
`_version`.((("version number (documents)")))

응답은 색인 하려는 요청이 성공적으로 생성되었다는 것을 보여주고, `_index`, `_type`, `_id` metadata와 새로운 요소 `_version`을 포함한다.((("version number (documents)")))

Every document in Elasticsearch has a version number. Every time a change is
made to a document (including deleting it), the `_version` number is
incremented. In <<version-control>>, we discuss how to use the `_version`
number to ensure that one part of your application doesn't overwrite changes
made by another part.

Elasticsearch에 있는 모든 document는 버전을 가지고 있다. document에 변화(삭제 포함)가 있을 때 마다, `_version` 넘버는 증가한다. 
 <<version-control>>에서, 응용프로그램의 어떤 부분이, 다른 부분에 의해 만들어진 변화를 덮어쓰지 않는다 것을 보장하기 위해, `_version`를 어떻게 사용하는지에 대해 이야기할 것이다.

==== Autogenerating IDs

==== 자동으로 생성되는 ID

If our data doesn't have a natural ID, we can let Elasticsearch autogenerate
one for us.  ((("id", "autogenerating")))The structure of the request changes: instead of using ((("HTTP methods", "POST")))((("POST method")))the `PUT`
verb (``store this document at this URL''), we use the `POST` verb (``store this document _under_ this URL'').

데이터에 고유의 식별자가 없다면, Elasticsearch가 자동으로 식별자를 생성하도록 할 수 있다.  ((("id", "autogenerating")))요청 구조에 변화가 있다. 
((("HTTP methods", "POST")))((("POST method")))`PUT`(``해당 URL에 이 document를 저장해라'')이 아닌, `POST`(``해당 URL _아래에_ 이 document를 저장해라'')를 사용한다.

The URL now contains just the `_index` and the `_type`:

URL은 이제 `_index`와 `_type`만을 가지고 있다:

[source,js]
--------------------------------------------------
POST /website/blog/
{
  "title": "My second blog entry",
  "text":  "Still trying this out...",
  "date":  "2014/01/01"
}
--------------------------------------------------
// SENSE: 030_Data/10_Create_doc_auto_ID.json

The response is similar to what we saw before, except that the `_id`
field has been generated for us:

응답은 `_id` field가 생성되었다는 점을 제외하면, 좀 전에 보았던 것과 유사하다:

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "wM0OSFhDQXGZAWDf0-drSA",
   "_version":  1,
   "created":   true
}
--------------------------------------------------

Autogenerated IDs are 22 character long, URL-safe, Base64-encoded string
_universally unique identifiers_, or((("UUIDs (universally unique identifiers)"))) http://en.wikipedia.org/wiki/Uuid[UUIDs].

자동으로 생성되는 ID는 URL-safe한 Base64로 인코딩된 문자열 (_범용 고유 식별자_) 또는 
((("UUIDs (universally unique identifiers)"))) http://en.wikipedia.org/wiki/Uuid[UUIDs]로 된 22자리 길이의 문자이다.


