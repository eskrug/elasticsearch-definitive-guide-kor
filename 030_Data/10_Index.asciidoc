[[index-doc]]
=== Indexing a Document

=== document를 색인하자.

Documents are _indexed_&#x2014;stored and made ((("documents", "indexing")))((("indexing", "a document")))searchable--by using the `index`
API. But first, we need to decide where the document  lives.  As we just
discussed, a document's `_index`, `_type`, and `_id` uniquely identify the
document.  We can either provide our own `_id` value or let the `index` API
generate one for us.

document는 index API에 의해 색인(저장되고 검색 가능하도록 만들어진)된다. 그러나 먼저, document를 어디에 저장할지를 결정해야 한다. 방금 이야기했듯이 document의 _index, _type, _id는 document를 유일하게 식별할 수 있다. 사용자가 _id 값을 지정하거나, 지정하지 않으면 Elasticsearch에서 자동으로 생성해 준다.

==== Using Our Own ID

==== 자기 자신의 id를 사용하려면

If your document has a natural ((("id", "providing for a document")))identifier (for example, a `user_account` field
or some other value that identifies the document), you should provide
your own `_id`, using this form of the `index` API:

만약 당신의 document가 고유의 식별자(예: user_account field나 document를 식별할 수 있는 어떤 다른 값)를 가지고 있다면, 아래 형태의 index API로, 자기 자신만의 _id를 제공할 수 있다.

[role="pagebreak-before"]
[source,js]
--------------------------------------------------
PUT /{index}/{type}/{id}
{
  "field": "value",
  ...
}
--------------------------------------------------

For example, if our index is called `website`, our type is called `blog`,
and we choose the ID `123`, then the index request looks like this:

예를 들자면, “website”라는 index에 “blog”라는 type에 “123”이라는 ID라면, index 요청은 아래와 같다.

[source,js]
--------------------------------------------------
PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "Just trying this out...",
  "date":  "2014/01/01"
}
--------------------------------------------------
// SENSE: 030_Data/10_Create_doc_123.json

Elasticsearch responds as follows:

Elasticsearch의 응답은 아래와 같다.

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "123",
   "_version":  1,
   "created":   true
}
--------------------------------------------------


The response indicates that the indexing request has been successfully created
and includes the `_index`, `_type`, and `_id` metadata, and a new element:
`_version`.((("version number (documents)")))

응답은 색인 하려는 요청이 성공적으로 생성되었다는 것을 보여주고, _index, _type, _id metadata와 새로운 요소 _version을 포함한다.

Every document in Elasticsearch has a version number. Every time a change is
made to a document (including deleting it), the `_version` number is
incremented. In <<version-control>>, we discuss how to use the `_version`
number to ensure that one part of your application doesn't overwrite changes
made by another part.

Elasticsearch에 있는 모든 document는 버전을 가지고 있다. document에 변화(삭제 포함)가 있을 때 마다, 버전은 증가한다. dealing with conflicts – 충돌을 다루어 보자(p.43)에서, 응용프로그램의 어떤 부분이, 다른 부분에 의해 만들어진 변화를 덮어쓰지 않는다 것을 보장하기 위해, 버전(_version)를 어떻게 사용하는지에 대해 이야기할 것이다.

==== Autogenerating IDs

==== 자동으로 생성되는 id

If our data doesn't have a natural ID, we can let Elasticsearch autogenerate
one for us.  ((("id", "autogenerating")))The structure of the request changes: instead of using ((("HTTP methods", "POST")))((("POST method")))the `PUT`
verb (``store this document at this URL''), we use the `POST` verb (``store this document _under_ this URL'').

데이터에 고유의 식별자가 없다면, Elasticsearch가 자동으로 식별자를 생성하도록 할 수 있다. 요청 구조에 변화가 있다. PUT(해당 URL에 이 document를 저장해라)이 아닌, POST(해당 URL 아래에 이 document를 저장해라)를 사용한다.

The URL now contains just the `_index` and the `_type`:

URL은 이제 _index와 _type만을 가지고 있다.

[source,js]
--------------------------------------------------
POST /website/blog/
{
  "title": "My second blog entry",
  "text":  "Still trying this out...",
  "date":  "2014/01/01"
}
--------------------------------------------------
// SENSE: 030_Data/10_Create_doc_auto_ID.json

The response is similar to what we saw before, except that the `_id`
field has been generated for us:

응답은 _id field가 생성되었다는 점을 제외하면, 좀 전에 보았던 것과 유사하다.

[source,js]
--------------------------------------------------
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "wM0OSFhDQXGZAWDf0-drSA",
   "_version":  1,
   "created":   true
}
--------------------------------------------------

Autogenerated IDs are 22 character long, URL-safe, Base64-encoded string
_universally unique identifiers_, or((("UUIDs (universally unique identifiers)"))) http://en.wikipedia.org/wiki/Uuid[UUIDs].

자동으로 생성되는 ID는 22자리 character로, UUID(Universally Unique Identifier)를 URL-safe하게 Base64로 encoding한 긴 문자열이다.


