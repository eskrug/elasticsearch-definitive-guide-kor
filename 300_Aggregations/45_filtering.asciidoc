
== query와 aggregation의 필터링

aggregation 범위 지정에 대한 자연스러운 확장은 필터링이다. aggregation은 query의 범위 지정 문맥에서 동작하므로, query에 적용된 어떠한 filter도 aggregation에 적용된다.

[float="true"]

=== 필터된 Query

$10,000 이상의 모든 자동차와 그 차들의 평균가를 계산하려면,((("filtering", "serch query results")))((("filtered query")))((("queries", "filtered"))) 
단순하게 `filtered` query를 사용할 수 있다:

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query" : {
        "filtered": {
            "filter": {
                "range": {
                    "price": {
                        "gte": 10000
                    }
                }
            }
        }
    },
    "aggs" : {
        "single_avg_price": {
            "avg" : { "field" : "price" }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json

기본적으로, `filtered` query를 사용하는 것은, 지난 장에서 설명한 것처럼, `match` query를 사용하는 것과 차이가 없다. 
query(filter를 포함하는 query)는 document의 특정 부분집합을 반환하고, aggregation은 해당 document에 대해 동작한다.

[float="true"]
=== Filter Bucket

하지만, 집계 결과를 필터링하고 싶다면?((("filtering", "aggregation results, not the query")))((("aggregations", "filtering just aggregations"))) 
자동차 대리점을 위한, 검색 페이지를 구현한다고 가정해 보자. 사용자의 검색 내용에 따라, 검색 결과를 표시해야 한다. 
그러나, 지난 달에 판매된 (검색에 일치하는) 자동차의 평균 가격을 포함하면, 페이지가 더 멋질 것이다.

두 가지의 다른 기준이 있기 때문에, 여기에서 단순한 범위 지정을 사용할 수 없다. 
검색 결과는 +ford+에 일치해야 한다. 그러나 집계 결과는 +ford+ 와 +sold > now - 1M+에 일치해야 한다.

이 이슈를 해결하기 위해, `filter`라 불리는 특별한 bucket을 사용할 수 있다.((("filter bucket")))((("buckets", "filter"))) 
filter를 지정하면, document가 filter의 기준에 일치하는 경우, 그들은 bucket에 추가된다.

아래가 결과 query 이다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
   "query":{
      "match": {
         "make": "ford"
      }
   },
   "aggs":{
      "recent_sales": {
         "filter": { <1>
            "range": {
               "sold": {
                  "from": "now-1M"
               }
            }
         },
         "aggs": {
            "average_price":{
               "avg": {
                  "field": "price" <2>
               }
            }
         }
      }
   }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json
<1> `filter`를 적용하기 위해, filter bucket을 사용한 것을 `query` 범위에 추가
<2> 그러므로, `avg` metric은, +ford+이고, 지난 달에 팔린 자동차의 평균일 것이다.

`filter` bucket은 다른 bucket과 마찬가지로 동작하기 때문에, 다른 bucket이나 metric 내부에 중첩하는 것이 
자유롭다. 모든 중첩된 요소는 filter를 `상속`한다. 이는 필요에 따라 aggregation의 선택적인 부분을 필터링할 수 있다는 것을 의미한다.

[float="true"]
=== Post Filter

이제, 검색 결과와 집계 양쪽 모두를 필터링(`filtered` query)하고, 집계의 개별 부분을 필터링 (`filtered` bucket)하는 방법을 알게 되었다(`filter` bucket).

"그럼, 집계가 아니라 단지 검색 결과만 필터링하는 방법이 있을까?"라는 생각이 들것이다.((("filtering", "search results, not the aggregation")))((("post filter"))) 
정답은 `post_filter`를 사용하는 것이다.

이것은 filter를 가지는, 최고 수준(top-level)의 검색 요청 요소이다. query가 실행된 _후에_, filter가 적용된다. (_query가 실행된 다음에_ 그것이 실행되기 때문에, +post+라는 이름으로 불린다.) 
query가 실행된 후에 그것이 동작하기 때문에, query의 범위에 영향을 미치지 않는다. 따라서, aggregation에도 영향을 미치지 않는다.

UI의 카테고리 같은 것에 영향을 미치지 않고, 검색 기준에 추가 filter를 적용하여, 이 동작을 사용할 수 있다. 
자동차 판매상을 위한 또 다른 검색 페이지를 계획해 보자. 이 페이지는 사용자가 자동차를 검색하고, 색상으로 필터링할 수 있다. 
색상 선택은 집계로 채워진다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query": {
        "match": {
            "make": "ford"
        }
    },
    "post_filter": {    <1>
        "term" : {
            "color" : "green"
        }
    },
    "aggs" : {
        "all_colors": {
            "terms" : { "field" : "color" }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json
<1> `post_filter` 요소는 +최고 수준(top-level)+의 요소이고, 검색 hit만을 필터링한다.

`query` 부분은 +ford+ 자동차를 검색한다. 그 다음에 `terms` aggregation으로, 색상 목록을 만든다. 
aggregation은 query 범위에서 동작하기 때문에, 색상 목록은 Ford 자동차에 칠해진 색상에 대응할 것이다.

마지막으로, `post_filter`는 녹색 +ford+ 자동차만을 보여주기 위해, 검색 결과를 필터링한다. 
이것은 query가 실행된 _후에_ 발생한다. 따라서 aggregation에 영향을 미치지 않는다.

이것은 종종 일관성 있는 UI에 있어 중요하다. 사용자가 UI에서 특정 카테고리(예: green)를 클릭한다고 가정해 보자. 
기대하는 것은 검색 결과가 필터링 되는 것이지, UI의 옵션이 _아니다_. `filtered` query를 적용하면, UI는
 옵션인 +green+_만을_ 보여주기 위해, 즉시 바뀔 것이다. 사용자가 바라는 것이 아니다.

[WARNING]
.성능에 대한 고려
====
검색 결과와 aggregation를 따로 필터링해야 한다면, `post_filter`_만_ 사용하자. ((("post filter", "performance and")))가끔 사람들은 일반 검색에 `post_filter`를 사용한다.

이렇게 하지 말자(그러지 마라!). `post_filter`의 본질은 query _후에_, 그것을 실행하는 것이다. 그렇게 하면, 필터링의 성능상 이점(cache 등)을 완전히 잃어버린다.

`post_filter`는 차별적인 필터링이 필요할 경우와 aggregation과 조합해서만 사용되어야 한다.
====

[float="true"]
=== Recap

필터링의 적절한 type(검색 hits, 집계 또는 둘 모두)을 선택하는 것은, 종종 사용자 인터페이스가 동작하는 방법으로 요약된다. 사용자에게 결과를 보여줄 방법에 따라, 적절한 filter나 조합을 선택하자.

 - A `filtered` query affects both search results and aggregations.
 - A `filter` bucket affects just aggregations.
 - A `post_filter` affects just search results.

 - A `filtered` 검색 결과와 집계 모두에 영향을 미친다.
 - A `filter` 집계에만 영향을 미친다.
 - A `post_filter` 검색 결과에만 영향을 미친다.
