
== Filtering Queries and Aggregations query와 집계의 필터링

집계 범위 지정에 대한 자연스러운 확장은 필터링이다. 집계는 query의 범위 지정 문맥에서 동작하므로, query에 적용된 어떠한 filter도 집계에 적용된다.
 A natural extension to aggregation scoping is filtering.  Because the aggregation
operates in the context of the query scope, any filter applied to the query
will also apply to the aggregation.

[float="true"]
=== Filtered Query
$10,000 이상의 모든 자동차와 그 차들의 평균가를 계산하려면, 단순하게 filtered query를 사용할 수 있다.
If we want to find all cars over $10,000 and also calculate the average price
for those cars,((("filtering", "serch query results")))((("filtered query")))((("queries", "filtered"))) we can simply use a `filtered` query:

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query" : {
        "filtered": {
            "filter": {
                "range": {
                    "price": {
                        "gte": 10000
                    }
                }
            }
        }
    },
    "aggs" : {
        "single_avg_price": {
            "avg" : { "field" : "price" }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json

기본적으로, filtered query를 사용하는 것은, 지난 장에서 설명한 것처럼, match query를 사용하는 것과 차이가 없다. query(filter를 포함하는 query)는 document의 특정 부분집합을 반환하고, 집계는 해당 document에 대해 동작한다.
Fundamentally, using a `filtered` query is no different from using a `match`
query, as we discussed in the previous chapter.  The query (which happens to include
a filter) returns a certain subset of documents, and the aggregation operates
on those documents.

[float="true"]
=== Filter Bucket

하지만, 집계 결과를 필터링하고 싶다면? 자동차 대리점을 위한, 검색 페이지를 구현한다고 가정해 보자. 사용자의 검색 내용에 따라, 검색 결과를 표시해야 한다. 그러나, 지난 달에 판매된 (검색에 일치하는) 자동차의 평균 가격을 포함하면, 페이지가 더 멋질 것이다.
But what if you would like to filter just the aggregation results?((("filtering", "aggregation results, not the query")))((("aggregations", "filtering just aggregations")))  Imagine we
are building the search page for our car dealership.  We want to display
search results according to what the user searches for.  But we also want
to enrich the page by including the average price of cars (matching the search)
that were sold in the last month.

두 가지의 다른 기준이 있기 때문에, 여기에서 단순한 범위 지정을 사용할 수 없다. 검색 결과는 “ford”에 일치해야 한다. 그러나 집계 결과는 “ford” 그리고 “sold > now - 1M”에 일치해야 한다.
We can't use simple scoping here, since there are two different criteria.  The
search results must match +ford+, but the aggregation results must match +ford+
AND +sold > now - 1M+.

이 이슈를 해결하기 위해, filter라 불리는 특별한 bucket을 사용할 수 있다. filter를 지정하면, document가 filter의 기준에 일치하는 경우, 그들은 bucket에 추가된다.
To solve this problem, we can use a special bucket called `filter`.((("filter bucket")))((("buckets", "filter")))  You specify
a filter, and when documents match the filter's criteria, they are added to the
bucket.

아래가 그 query이다.
Here is the resulting query:

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
   "query":{
      "match": {
         "make": "ford"
      }
   },
   "aggs":{
      "recent_sales": {
         "filter": { <1>
            "range": {
               "sold": {
                  "from": "now-1M"
               }
            }
         },
         "aggs": {
            "average_price":{
               "avg": {
                  "field": "price" <2>
               }
            }
         }
      }
   }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json
 filter를 적용하기 위해, filter bucket을 사용한 것을 query 범위에 추가
<1> Using the `filter` bucket to apply a filter in addition to the `query` scope.
 그러므로, avg metric은, “ford”이고, 지난 달에 팔린 자동차의 평균일 것이다.
<2> This `avg` metric will therefore average only docs that are both +ford+ and sold in the last month.

filter bucket은 다른 bucket과 마찬가지로 동작하기 때문에, 다른 bucket이나 metric 내부에 중첩하는 것이 자유롭다. 모든 중첩된 요소는 filter를 “상속(inherit)”한다. 이는 필요에 따라 집계의 선택적인 부분을 필터링할 수 있다는 것을 의미한다.
Since the `filter` bucket operates like any other bucket, you are free to nest
other buckets and metrics inside.  All nested components will "inherit" the filter.
This allows you to filter selective portions of the aggregation as required.

[float="true"]
=== Post Filter

이제, 검색 결과와 집계 양쪽 모두를 필터링(filtered query)하고, 집계의 개별 부분을 필터링 (filtered bucket)하는 방법을 알게 되었다.
So far, we have a way to filter both the search results and aggregations (a
`filtered` query), as well as filtering individual portions of the aggregation
(`filter` bucket).

“그럼, 집계가 아니라 단지 검색 결과만 필터링하는 방법이 있을까?”라는 생각이 들것이다. 정답은 post_filter를 사용하는 것이다.
You may be thinking to yourself, "hmm...is there a way to filter _just_ the search
results but not the aggregation?"((("filtering", "search results, not the aggregation")))((("post filter")))  The answer is to use a `post_filter`.

이것은 filter를 가지는, 최고 수준(top-level)의 검색 요청 요소이다. query가 실행된 후에, filter가 적용된다. (query가 실행된 다음에 그것이 실행되기 때문에, “post”라는 이름으로 불린다.) query가 실행된 후에 그것이 동작하기 때문에, query의 범위에 영향을 미치지 않는다. 따라서, 집계에도 영향을 미치지 않는다.
This is a top-level search-request element that accepts a filter.  The filter is
applied _after_ the query has executed (hence the +post+ moniker: it runs
_post query_ execution).  Because it operates after the query has executed,
it does not affect the query scope--and thus does not affect the aggregations
either.

UI의 카테고리 같은 것에 영향을 미치지 않고, 검색 기준에 추가 filter를 적용하여, 이 동작을 사용할 수 있다. 자동차 판매상을 위한 또 다른 검색 페이지를 계획해 보자. 이 페이지는 사용자가 자동차를 검색하고, 색상으로 필터링할 수 있다. 색상 선택은 집계로 채워진다.
We can use this behavior to apply additional filters to our search
criteria that don't affect things like categorical facets in your UI.  Let's
design another search page for our car dealer.  This page will allow the user
to search for a car and filter by color.  Color choices are populated via an
aggregation:

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query": {
        "match": {
            "make": "ford"
        }
    },
    "post_filter": {    <1>
        "term" : {
            "color" : "green"
        }
    },
    "aggs" : {
        "all_colors": {
            "terms" : { "field" : "color" }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json
 post_filter 요소는 “최고 수준(top-level)”의 요소이고, 검색 hit만을 필터링한다.
<1> The `post_filter` element is a +top-level+ element and filters just the search hits.

query 부분은 “ford” 자동차를 검색한다. 그 다음에 terms 집계로, 색상 목록을 만든다. 집계는 query 범위에서 동작하기 때문에, 색상 목록은 Ford 자동차에 칠해진 색상에 대응할 것이다.
The `query` portion is finding all +ford+ cars.  We are then building a list of
colors with a `terms` aggregation.  Because aggregations operate in the query
scope, the list of colors will correspond with the colors that Ford cars are
painted.

마지막으로, post_filter는 녹색 “ford” 자동차만을 보여주기 위해, 검색 결과를 필터링한다. 이것은 query가 실행된 후에 발생한다. 따라서 집계에 영향을 미치지 않는다.
Finally, the `post_filter` will filter the search results to show only green
+ford+ cars.  This happens _after_ the query is executed, so the aggregations
are unaffected.

이것은 일관성 있는 UI에 있어 중요하다. 사용자가 UI에서 특정 카테고리(예: green)를 클릭한다고 가정해 보자. 기대하는 것은 검색 결과가 필터링 되는 것이지, UI의 옵션이 아니다. filtered query를 적용하면, UI는 옵션인 “green”만을 보여주기 위해, 즉시 바뀔 것이다. 사용자가 바라는 것이 아니다.
This is often important for coherent UIs.  Imagine that a user clicks a category in
your UI (for example, green).  The expectation is that the search results are filtered,
but _not_ the UI options.  If you applied a `filtered` query, the UI would
instantly transform to show _only_ +green+ as an option--not what the user wants!

[WARNING]
.Performance consideration 성능에 대한 고려
====
검색 결과와 집계를 따로 필터링해야 한다면, post_filter만 사용하자. 가끔 사람들은 일반 검색에 post_filter를 사용한다.
Use a `post_filter` _only_ if you need to differentially filter search results
and aggregations. ((("post filter", "performance and")))Sometimes people will use `post_filter` for regular searches.

이렇게 하지 말자. post_filter의 본질은 query 후에, 그것을 실행하는 것이다. 그렇게 하면, 필터링의 성능상 이점(cache 등)을 완전히 잃어버린다.
Don't do this!  The nature of the `post_filter` means it runs _after_ the query,
so any performance benefit of filtering (such as caches) is lost completely.

post_filter는 집계와 조합해서만, 그리고 차별적인 필터링이 필요할 경우에만, 사용되어야 한다.
The `post_filter` should be used only in combination with aggregations, and only
when you need differential filtering.
====

[float="true"]
=== Recap

필터링의 적절한 type(검색 hits, 집계 또는 둘 모두)을 선택하는 것은, 종종 사용자 인터페이스가 동작하는 방법으로 요약된다. 사용자에게 결과를 나타내는 방법에 따라, 적절한 filter나 조합을 선택하자.
Choosing the appropriate type of filtering--search hits, aggregations, or
both--often boils down to how you want your user interface to behave.  Choose
the appropriate filter (or combinations) depending on how you want to display
results to your user.

검색 결과와 집계 모두에 영향을 미친다.
 - A `filtered` query affects both search results and aggregations.
 집계에만 영향을 미친다.
 - A `filter` bucket affects just aggregations.
 검색 결과에만 영향을 미친다.
 - A `post_filter` affects just search results.
