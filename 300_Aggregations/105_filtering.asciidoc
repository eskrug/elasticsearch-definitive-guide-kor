=== fielddata 필터링

사용자들이 각자가 좋아하는 노래를 들을 수 있는 website를 운영 중이라고 가정해 보자.((("fielddata", "filtering")))((("aggregations", "fielddata", "filtering")))  
사용자들이 각자의 음악 라이브러리를 쉽게 관리하도록 하기 위해서, 그들이 원하는 어떠한 tag라도 노래에 달 수 있게 하였다. 
`rock`, `hiphop`, `electronica` 등으로 tag된 많은 노래뿐만 아니라, `my_16th_birthday_favourite_anthem(나의 16번째 생일에 매우 좋아했던 기념)`이라고 tag된 곡도 보게 될 것이다.

이제 각 노래에 대해, 가장 인기를 끌고 있는 3개의 tag를, 사용자에게 보여 주려 한다고 가정해보자. 
rock같은 tag는 상위 3개 안에 들 것이 확실하다. 그러나, `my_16th_birthday_favourite_a-nthem`은 순위를 확인하기가 매우 어려울 것이다. 
그러나 가장 인기를 끌고 있는 tag를 계산하기 위해, 이러한 일회성 단어 모두를 메모리에 로드 할 수 밖에 없다.

fielddata 필터링 덕분에, 이 상황을 제어할 수 있다. 
가장 인기를 끌고 있는 단어에만 관심이 있다는 것을 _알기_ 때문에, 관심이 적은 불필요한 단어의 로드를 방지할 수 있다:

[source,js]
----
PUT /music/_mapping/song
{
  "properties": {
    "tag": {
      "type": "string",
      "fielddata": { <1>
        "filter": {
          "frequency": { <2>
            "min":              0.01, <3>
            "min_segment_size": 500  <4>
          }
        }
      }
    }
  }
}
----
<1> `fielddata` key는 이 field에 대해 fielddata를 다루는 방법을 설정한다,
<2> `frequency` filter는 Term Frequency를 기반으로, fielddata 로드를 필터링한다.((("term frequency", "fielddata filtering based on")))
<3> 이 segment에서 document 중 최소한 1% 이상 나타나는 단어만 로드
<4> 500개 이하의 document를 가지고 있는 segment는 무시 한다.

이 mapping이 준비가 되면, _해당 segment_의 document 중, 
최소한 1% 이상 나타나는 단어만 메모리에 로드 될 것이다. `max` Term Frequency(max)를 지정할 수도 있는데, 
이는 (<<stopwords,불용어>>처럼, _아주_ 흔한 단어를 제외하는데 사용될 수 있다.

이 경우에, term frequency는 segment별로 계산된다. 이것은 구현상의 한계이다. 
fielddata는 segment별로 로드 되고, 그 시점에서 볼 수 있는 term frequency만이 해당 segment에 대한 빈도이다. 
그러나 이 제한은 재미있는 특성을 가지고 있다. 새로 인기를 끌고 얻는 단어는 빠르게 상위권으로 올라온다.

어느 날 새로운 장르의 노래가 인기를 끌고 있다고 가정해 보자. 이 새로운 장르에 대한 tag를 가장 인기를 끌고 있는 목록에 포함하고 싶지만, 
전체 index에 대해 계산된 term frequency에 의존한다면, 새로운 tag가 `rock`, `electronica`만큼 인기를 끌 때까지 기다려야 한다. 
frequency 필터링 방식으로 구현되었기 때문에, 새롭게 추가된 tag는 새로운 segment내 높은 빈도의 tag로써, 
빠르게 눈에 띄게 될 것이다. 따라서, 빠르게 상위권으로 떠오를 것이다.

`min_segment_size` 매개변수는 특정 크기 이하의 segment를 무시하도록 한다.((("min_segment_size parameter"))) 
segment가 소수의 document만을 가지고 있다면, term frequency는 어떤 의미를 가지기에는 너무 조잡하다. 
작은 segment가 더 큰 segment에 곧 병합되면, 의미를 가지게 된다.

[TIP]
====
frequency로 단어를 필터링하는 것 외에도 옵션이 있다. 정규식에 일치하는 해당 단어만을 로드할 수도 있다. 
예를 들어, hashtag(`#`으로 시작하는 단어)만을 메모리에 로드 하기 위해, tweets에 `정규식` filter를((("regex filtering"))) 사용할 수 있다. 
이것은 `whitespace` analyzer 같은, 구두점을 유지하는 analyzer를 사용한다고 가정한 것이다. 
====

fielddata 필터링은 메모리 사용에 _막대한_ 영향을 끼칠 수 있다. 
trade-off는 매우 알기 쉽다. 여러분은 본질적으로 데이터를 무시하고 있다. 
하지만, 많은 응용프로그램에서, 데이터는 어쨌든 사용되지 않고 있기 때문에, trade-off는 합리적이다. 
메모리의 절약은 크고 상대적으로 쓸모 없는 단어를 포함하는 것보다 더 중요하다.
